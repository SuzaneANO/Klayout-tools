<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description>PDK Layer Browser (Python)</description>
 <version>2.0</version>
 <category/>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <priority>0</priority>
 <shortcut>Ctrl+Shift+L</shortcut>
 <show-in-menu>true</show-in-menu>
 <group-name/>
 <menu-path>tools_menu.end</menu-path>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>
# PDK Layer Browser - Python Version
# Browse through PDK layers one by one with isolation mode
# Supports .tech and .lyp layer map files
#
# Keyboard Shortcuts:
#   N     - Next layer
#   P     - Previous layer
#   K     - Keep/pin current layer
#   C     - Clear kept layers
#   A     - Show all layers
#   I     - Toggle isolate mode
#   L     - Load layer map

import pya
import re
import os

class LayerBrowserDialog(pya.QDialog):
    def __init__(self, view, parent=None):
        super(LayerBrowserDialog, self).__init__(parent)
        
        self.view = view
        self.current_idx = 0
        self.layers = []
        self.layer_map = {}
        self.lyp_file = None
        self.isolate_mode = True
        self.kept_layers = []
        
        self.setWindowTitle("PDK Layer Browser")
        self.setMinimumWidth(500)
        self.setMinimumHeight(650)
        
        self.setup_ui()
        self.refresh_layers()
        self.update_display()
    
    def setup_ui(self):
        layout = pya.QVBoxLayout(self)
        
        # Current layer info
        info_group = pya.QGroupBox("Current Layer", self)
        info_layout = pya.QVBoxLayout(info_group)
        
        self.name_label = pya.QLabel("", self)
        self.name_label.setStyleSheet("font-size: 14pt; font-weight: bold; color: #2196F3;")
        info_layout.addWidget(self.name_label)
        
        self.info_label = pya.QLabel("", self)
        info_layout.addWidget(self.info_label)
        
        self.shape_label = pya.QLabel("", self)
        info_layout.addWidget(self.shape_label)
        
        layout.addWidget(info_group)
        
        # Progress
        progress_layout = pya.QHBoxLayout()
        self.progress_label = pya.QLabel("Layer 0 of 0", self)
        progress_layout.addWidget(self.progress_label)
        self.progress_bar = pya.QProgressBar(self)
        progress_layout.addWidget(self.progress_bar)
        layout.addLayout(progress_layout)
        
        # Navigation
        nav_group = pya.QGroupBox("Navigation", self)
        nav_layout = pya.QHBoxLayout(nav_group)
        
        self.prev_btn = pya.QPushButton("&lt;&lt; Prev (P)", self)
        self.prev_btn.clicked(self.navigate_prev)
        nav_layout.addWidget(self.prev_btn)
        
        self.layer_spin = pya.QSpinBox(self)
        self.layer_spin.setMinimum(0)
        self.layer_spin.valueChanged(self.jump_to_layer)
        nav_layout.addWidget(self.layer_spin)
        
        self.next_btn = pya.QPushButton("Next (N) &gt;&gt;", self)
        self.next_btn.clicked(self.navigate_next)
        nav_layout.addWidget(self.next_btn)
        
        layout.addWidget(nav_group)
        
        # Layer list with search
        list_group = pya.QGroupBox("All Layers", self)
        list_layout = pya.QVBoxLayout(list_group)
        
        search_layout = pya.QHBoxLayout()
        search_layout.addWidget(pya.QLabel("Search:", self))
        self.search_edit = pya.QLineEdit(self)
        self.search_edit.setPlaceholderText("Filter layers...")
        self.search_edit.textChanged(self.filter_layers)
        search_layout.addWidget(self.search_edit)
        list_layout.addLayout(search_layout)
        
        self.layer_list = pya.QListWidget(self)
        self.layer_list.currentRowChanged(self.select_from_list)
        list_layout.addWidget(self.layer_list)
        
        layout.addWidget(list_group)
        
        # Options
        options_group = pya.QGroupBox("Options", self)
        options_layout = pya.QVBoxLayout(options_group)
        
        self.isolate_cb = pya.QCheckBox("Isolate current layer (I)", self)
        self.isolate_cb.setChecked(self.isolate_mode)
        self.isolate_cb.stateChanged(self.toggle_isolate)
        options_layout.addWidget(self.isolate_cb)
        
        self.zoom_cb = pya.QCheckBox("Auto-zoom to layer", self)
        options_layout.addWidget(self.zoom_cb)
        
        layout.addWidget(options_group)
        
        # PDK Layer Map
        pdk_group = pya.QGroupBox("PDK Layer Map", self)
        pdk_layout = pya.QVBoxLayout(pdk_group)
        
        self.lyp_label = pya.QLabel("No layer map loaded", self)
        self.lyp_label.setStyleSheet("color: gray;")
        pdk_layout.addWidget(self.lyp_label)
        
        pdk_btn_layout = pya.QHBoxLayout()
        
        self.load_btn = pya.QPushButton("Load Map (L)", self)
        self.load_btn.clicked(self.load_layer_map)
        pdk_btn_layout.addWidget(self.load_btn)
        
        self.clear_btn = pya.QPushButton("Clear", self)
        self.clear_btn.clicked(self.clear_layer_map)
        pdk_btn_layout.addWidget(self.clear_btn)
        
        pdk_layout.addLayout(pdk_btn_layout)
        layout.addWidget(pdk_group)
        
        # Kept layers
        kept_group = pya.QGroupBox("Kept Layers (K to add, C to clear)", self)
        kept_layout = pya.QVBoxLayout(kept_group)
        
        self.kept_list = pya.QListWidget(self)
        self.kept_list.setMaximumHeight(80)
        kept_layout.addWidget(self.kept_list)
        
        kept_btn_layout = pya.QHBoxLayout()
        self.keep_btn = pya.QPushButton("Keep Current (K)", self)
        self.keep_btn.clicked(self.keep_current)
        kept_btn_layout.addWidget(self.keep_btn)
        
        self.clear_kept_btn = pya.QPushButton("Clear All (C)", self)
        self.clear_kept_btn.clicked(self.clear_kept)
        kept_btn_layout.addWidget(self.clear_kept_btn)
        
        kept_layout.addLayout(kept_btn_layout)
        layout.addWidget(kept_group)
        
        # Action buttons
        btn_layout = pya.QHBoxLayout()
        
        self.show_all_btn = pya.QPushButton("Show All (A)", self)
        self.show_all_btn.clicked(self.show_all_layers)
        btn_layout.addWidget(self.show_all_btn)
        
        self.refresh_btn = pya.QPushButton("Refresh", self)
        self.refresh_btn.clicked(self.on_refresh)
        btn_layout.addWidget(self.refresh_btn)
        
        self.close_btn = pya.QPushButton("Close", self)
        self.close_btn.clicked(self.accept)
        btn_layout.addWidget(self.close_btn)
        
        layout.addLayout(btn_layout)
        
        # Status
        self.status_label = pya.QLabel("", self)
        self.status_label.setStyleSheet("color: gray; font-style: italic;")
        layout.addWidget(self.status_label)
    
    def refresh_layers(self):
        self.layers = []
        self.layer_list.clear()
        self.filtered_indices = []
        
        if not self.view or not self.view.cellview(0):
            return
        
        iter = self.view.begin_layers()
        while not iter.at_end():
            lp = iter.current()
            if lp.valid:
                layer_num = lp.source_layer
                datatype = lp.source_datatype
                
                pdk_name = self.get_pdk_name(layer_num, datatype)
                
                if pdk_name:
                    display = pdk_name
                elif lp.name:
                    display = lp.name
                else:
                    display = f"{layer_num}/{datatype}"
                
                self.layers.append({
                    'prop': lp,
                    'name': display,
                    'pdk_name': pdk_name,
                    'layer': layer_num,
                    'datatype': datatype
                })
                self.filtered_indices.append(len(self.layers) - 1)
            iter.next()
        
        self.populate_list()
        
        max_val = max(len(self.layers) - 1, 0)
        self.layer_spin.setMaximum(max_val)
        self.progress_bar.setMaximum(max_val)
    
    def populate_list(self, filter_text=""):
        self.layer_list.blockSignals(True)
        self.layer_list.clear()
        self.filtered_indices = []
        
        filter_lower = filter_text.lower()
        for i, layer in enumerate(self.layers):
            display = f"{i}: {layer['name']} ({layer['layer']}/{layer['datatype']})"
            if not filter_text or filter_lower in display.lower():
                self.layer_list.addItem(display)
                self.filtered_indices.append(i)
        
        self.layer_list.blockSignals(False)
    
    def filter_layers(self, text):
        self.populate_list(text)
    
    def get_pdk_name(self, layer, datatype):
        key = f"{layer}/{datatype}"
        return self.layer_map.get(key)
    
    def update_display(self):
        if not self.layers:
            return
        
        layer = self.layers[self.current_idx]
        
        if layer['pdk_name']:
            self.name_label.setText(layer['pdk_name'])
            self.name_label.setStyleSheet("font-size: 14pt; font-weight: bold; color: #4CAF50;")
        else:
            self.name_label.setText(layer['name'])
            self.name_label.setStyleSheet("font-size: 14pt; font-weight: bold; color: #2196F3;")
        
        self.info_label.setText(f"Layer: {layer['layer']} / Datatype: {layer['datatype']}")
        
        self.progress_label.setText(f"Layer {self.current_idx + 1} of {len(self.layers)}")
        self.progress_bar.setValue(self.current_idx)
        
        self.layer_spin.blockSignals(True)
        self.layer_spin.setValue(self.current_idx)
        self.layer_spin.blockSignals(False)
        
        # Select in list
        if self.current_idx in self.filtered_indices:
            row = self.filtered_indices.index(self.current_idx)
            self.layer_list.blockSignals(True)
            self.layer_list.setCurrentRow(row)
            self.layer_list.blockSignals(False)
        
        if self.isolate_mode:
            self.isolate_layer()
        
        if self.zoom_cb.isChecked():
            self.zoom_to_layer()
    
    def isolate_layer(self):
        if not self.layers:
            return
        
        # Hide all
        iter = self.view.begin_layers()
        while not iter.at_end():
            iter.current().visible = False
            iter.next()
        
        # Show current
        self.layers[self.current_idx]['prop'].visible = True
        
        # Show kept
        for idx in self.kept_layers:
            if 0 &lt;= idx &lt; len(self.layers):
                self.layers[idx]['prop'].visible = True
    
    def show_all_layers(self):
        iter = self.view.begin_layers()
        while not iter.at_end():
            iter.current().visible = True
            iter.next()
        self.status_label.setText("All layers visible")
    
    def navigate_next(self):
        if self.layers:
            self.current_idx = (self.current_idx + 1) % len(self.layers)
            self.update_display()
    
    def navigate_prev(self):
        if self.layers:
            self.current_idx = (self.current_idx - 1) % len(self.layers)
            self.update_display()
    
    def jump_to_layer(self, idx):
        if self.layers and 0 &lt;= idx &lt; len(self.layers):
            self.current_idx = idx
            self.update_display()
    
    def select_from_list(self, row):
        if 0 &lt;= row &lt; len(self.filtered_indices):
            self.current_idx = self.filtered_indices[row]
            self.update_display()
    
    def toggle_isolate(self, state):
        self.isolate_mode = (state == pya.Qt.Checked)
        if self.isolate_mode:
            self.isolate_layer()
        else:
            self.show_all_layers()
    
    def keep_current(self):
        if not self.layers:
            return
        if self.current_idx not in self.kept_layers:
            self.kept_layers.append(self.current_idx)
            self.update_kept_list()
            self.status_label.setText(f"Kept: {self.layers[self.current_idx]['name']}")
        if self.isolate_mode:
            self.isolate_layer()
    
    def clear_kept(self):
        self.kept_layers = []
        self.update_kept_list()
        self.status_label.setText("Cleared kept layers")
        if self.isolate_mode:
            self.isolate_layer()
    
    def update_kept_list(self):
        self.kept_list.clear()
        for idx in self.kept_layers:
            if 0 &lt;= idx &lt; len(self.layers):
                layer = self.layers[idx]
                self.kept_list.addItem(f"{idx}: {layer['name']}")
    
    def zoom_to_layer(self):
        if not self.layers:
            return
        layer = self.layers[self.current_idx]
        cv = self.view.cellview(0)
        if cv and cv.cell:
            layout = cv.layout()
            layer_idx = layout.find_layer(layer['layer'], layer['datatype'])
            if layer_idx is not None and layout.is_valid_layer(layer_idx):
                bbox = cv.cell.bbox_per_layer(layer_idx)
                if bbox and not bbox.empty():
                    self.view.zoom_box(bbox.enlarged(bbox.width() * 0.1, bbox.height() * 0.1))
    
    def on_refresh(self):
        self.refresh_layers()
        self.update_display()
    
    def load_layer_map(self):
        path = pya.FileDialog.get_open_file_name(
            "Load Layer Map", ".",
            "Tech File (*.tech);;Layer Properties (*.lyp);;All (*)"
        )
        path = str(path)
        if not path:
            return
        
        try:
            with open(path, 'r') as f:
                content = f.read()
            
            self.layer_map = {}
            
            if path.lower().endswith('.tech'):
                # Parse .tech file
                cif_start = content.find('cifoutput')
                if cif_start &gt;= 0:
                    cif_section = content[cif_start:]
                    current_layer = None
                    for line in cif_section.split('\n'):
                        line = line.strip()
                        m = re.match(r'^layer\s+(\w+)', line)
                        if m:
                            current_layer = m.group(1)
                        elif current_layer:
                            m = re.match(r'^calma\s+(\d+)\s+(\d+)', line)
                            if m:
                                key = f"{m.group(1)}/{m.group(2)}"
                                self.layer_map[key] = current_layer
                                current_layer = None
            else:
                # Parse .lyp file
                for m in re.finditer(r'&lt;properties&gt;(.*?)&lt;/properties&gt;', content, re.DOTALL):
                    block = m.group(1)
                    name_m = re.search(r'&lt;name&gt;([^&lt;]+)&lt;/name&gt;', block)
                    src_m = re.search(r'&lt;source&gt;([^&lt;]+)&lt;/source&gt;', block)
                    if name_m and src_m:
                        name = name_m.group(1).strip()
                        src = src_m.group(1).strip()
                        layer_m = re.search(r'(\d+)/(\d+)', src)
                        if layer_m:
                            key = f"{layer_m.group(1)}/{layer_m.group(2)}"
                            layer_name = name.split(" - ")[0].strip()
                            self.layer_map[key] = layer_name
            
            self.lyp_file = path
            self.lyp_label.setText(f"Loaded: {os.path.basename(path)} ({len(self.layer_map)} layers)")
            self.lyp_label.setStyleSheet("color: green; font-weight: bold;")
            self.refresh_layers()
            self.update_display()
            self.status_label.setText(f"Loaded {len(self.layer_map)} mappings")
            
        except Exception as e:
            pya.MessageBox.critical("Error", str(e), pya.MessageBox.Ok)
    
    def clear_layer_map(self):
        self.layer_map = {}
        self.lyp_file = None
        self.lyp_label.setText("No layer map loaded")
        self.lyp_label.setStyleSheet("color: gray;")
        self.refresh_layers()
        self.update_display()
    
    def keyPressEvent(self, event):
        key = event.key()
        if key == pya.Qt.Key_N:
            self.navigate_next()
        elif key == pya.Qt.Key_P:
            self.navigate_prev()
        elif key == pya.Qt.Key_K:
            self.keep_current()
        elif key == pya.Qt.Key_C:
            self.clear_kept()
        elif key == pya.Qt.Key_A:
            self.show_all_layers()
        elif key == pya.Qt.Key_I:
            self.isolate_cb.setChecked(not self.isolate_cb.isChecked())
        elif key == pya.Qt.Key_L:
            self.load_layer_map()
        elif key == pya.Qt.Key_Home:
            self.jump_to_layer(0)
        elif key == pya.Qt.Key_End:
            self.jump_to_layer(len(self.layers) - 1)
        else:
            super(LayerBrowserDialog, self).keyPressEvent(event)


# Run dialog
app = pya.Application.instance()
mw = app.main_window()
view = mw.current_view()

if view:
    dialog = LayerBrowserDialog(view, mw)
    dialog.exec_()
else:
    pya.MessageBox.warning("No View", "Please open a layout first.", pya.MessageBox.Ok)
</text>
</klayout-macro>
